---
title: "Vue.js性能优化与调试技巧"
excerpt: "深入探讨Vue.js应用的性能优化策略，包括渲染性能优化、内存管理、打包优化等方面，并介绍实用的调试技巧和工具，帮助开发者构建高性能、可维护的Vue应用"
coverImage: "/assets/blog/hello-world/cover.jpg"
date: "2025-10-10"
author:
  name: 小羽
  picture: "/assets/blog/authors/jj.jpeg"
ogImage:
  url: "/assets/blog/hello-world/cover.jpg"
---

# Vue.js性能优化与调试技巧

## 前言

随着前端应用规模的增长，性能优化和调试技巧变得越来越重要。Vue.js作为一款现代化的前端框架，提供了丰富的性能优化工具和调试手段。本文将深入探讨Vue.js应用的性能优化策略，包括渲染性能优化、内存管理、打包优化等方面，并介绍实用的调试技巧和工具，帮助开发者构建高性能、可维护的Vue应用。

## 渲染性能优化

### 虚拟DOM与Diff算法优化

Vue的虚拟DOM和Diff算法是其高性能的核心，但不当的使用方式可能导致性能问题。

```javascript
// 避免不必要的响应式数据
// 不好的做法 - 将大量数据设为响应式
export default {
  data() {
    return {
      largeList: [] // 可能包含数千个项目的数组
    }
  },
  created() {
    // 一次性加载大量数据
    this.largeList = Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      name: `Item ${i}`,
      description: `Description for item ${i}`,
      // 更多属性...
    }))
  }
}

// 好的做法 - 使用Object.freeze或shallowRef
import { shallowRef } from 'vue'

export default {
  setup() {
    // 使用shallowRef避免深层响应式
    const largeList = shallowRef([])
    
    // 或者使用Object.freeze
    const staticData = Object.freeze(
      Array.from({ length: 10000 }, (_, i) => ({
        id: i,
        name: `Item ${i}`,
        description: `Description for item ${i}`
      }))
    )
    
    // 在需要时更新
    function updateList() {
      largeList.value = [...newList]
    }
    
    return { largeList, staticData, updateList }
  }
}
```

### 合理使用key属性

key属性在Vue的Diff算法中起着关键作用，正确使用可以显著提升列表渲染性能。

```javascript
// 不好的做法 - 使用索引作为key
<template>
  <div>
    <div v-for="(item, index) in items" :key="index">
      {{ item.name }}
    </div>
  </div>
</template>

// 好的做法 - 使用唯一稳定的ID作为key
<template>
  <div>
    <div v-for="item in items" :key="item.id">
      {{ item.name }}
    </div>
  </div>
</template>

// 当没有唯一ID时，可以使用组合属性
<template>
  <div>
    <div v-for="(item, index) in items" :key="`${item.name}-${index}`">
      {{ item.name }}
    </div>
  </div>
</template>
```

### 计算属性缓存

计算属性基于依赖进行缓存，合理使用可以避免重复计算。

```javascript
// 不好的做法 - 在模板中进行复杂计算
<template>
  <div>
    <div v-for="user in users" :key="user.id">
      {{ user.firstName + ' ' + user.lastName }}
      {{ getFormattedDate(user.birthDate) }}
      {{ calculateAge(user.birthDate) }}
    </div>
  </div>
</template>

// 好的做法 - 使用计算属性
<template>
  <div>
    <div v-for="user in formattedUsers" :key="user.id">
      {{ user.fullName }}
      {{ user.formattedBirthDate }}
      {{ user.age }}
    </div>
  </div>
</template>

<script>
import { computed } from 'vue'

export default {
  props: {
    users: Array
  },
  
  setup(props) {
    const formattedUsers = computed(() => {
      return props.users.map(user => ({
        ...user,
        fullName: `${user.firstName} ${user.lastName}`,
        formattedBirthDate: getFormattedDate(user.birthDate),
        age: calculateAge(user.birthDate)
      }))
    })
    
    return { formattedUsers }
  }
}

// 对于复杂计算，可以使用memoization
import { memoize } from 'lodash-es'

const calculateAge = memoize((birthDate) => {
  // 复杂的年龄计算逻辑
  const today = new Date()
  const birth = new Date(birthDate)
  let age = today.getFullYear() - birth.getFullYear()
  const monthDiff = today.getMonth() - birth.getMonth()
  
  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birth.getDate())) {
    age--
  }
  
  return age
})
</script>
```

### 侦听器优化

侦听器可以响应数据变化，但不当使用可能导致性能问题。

```javascript
// 不好的做法 - 侦听深层对象
export default {
  data() {
    return {
      user: {
        profile: {
          personal: {
            name: '',
            email: '',
            // 深层嵌套结构...
          }
        }
      }
    }
  },
  watch: {
    // 侦听整个对象，任何属性变化都会触发
    user: {
      handler(newVal, oldVal) {
        // 处理逻辑...
      },
      deep: true // 深度侦听，性能开销大
    }
  }
}

// 好的做法 - 侦听特定属性
export default {
  data() {
    return {
      user: {
        profile: {
          personal: {
            name: '',
            email: ''
          }
        }
      }
    }
  },
  watch: {
    // 只侦听需要的属性
    'user.profile.personal.name': {
      handler(newName, oldName) {
        // 处理逻辑...
      }
    },
    
    // 或者使用计算属性
    userName: {
      handler(newName, oldName) {
        // 处理逻辑...
      }
    }
  },
  computed: {
    userName() {
      return this.user.profile.personal.name
    }
  }
}

// 使用组合式API的watchEffect和watch
import { watch, watchEffect, ref } from 'vue'

export default {
  setup() {
    const user = ref({
      profile: {
        personal: {
          name: '',
          email: ''
        }
      }
    })
    
    // watchEffect自动追踪依赖，但可能执行多次
    watchEffect(() => {
      console.log('User name changed:', user.value.profile.personal.name)
    })
    
    // watch明确指定依赖，更精确控制
    watch(
      () => user.value.profile.personal.name,
      (newName, oldName) => {
        console.log('User name changed:', newName, oldName)
      }
    )
    
    // 侦听多个源
    watch(
      [
        () => user.value.profile.personal.name,
        () => user.value.profile.personal.email
      ],
      ([newName, newEmail], [oldName, oldEmail]) => {
        console.log('User info changed:', { newName, newEmail })
      }
    )
    
    return { user }
  }
}
```

## 组件性能优化

### 函数式组件

函数式组件是无状态的、没有实例的轻量级组件，适合用于简单的展示场景。

```javascript
// Vue 2中的函数式组件
export default {
  functional: true,
  props: ['level', 'title'],
  render(h, { props, children }) {
    return h(`h${props.level}`, { attrs: { title: props.title } }, children)
  }
}

// Vue 3中的函数式组件
// 对于简单的展示组件，可以直接使用函数
const FunctionalHeading = (props, context) => {
  return h(`h${props.level}`, { title: props.title }, context.slots.default())
}

FunctionalHeading.props = ['level', 'title']

// 在模板中使用
<template>
  <FunctionalHeading :level="1" title="Main Title">
    Hello World
  </FunctionalHeading>
</template>

// 或者使用动态组件
<template>
  <component :is="`h${level}`" :title="title">
    <slot></slot>
  </component>
</template>

<script>
export default {
  props: ['level', 'title']
}
</script>
```

### 组件懒加载

对于大型应用，使用组件懒加载可以减少初始包大小，提高首屏加载速度。

```javascript
// 路由级别的懒加载
const routes = [
  {
    path: '/about',
    component: () => import('./views/About.vue')
  }
]

// 组件级别的懒加载
export default {
  components: {
    'heavy-component': () => import('./HeavyComponent.vue')
  }
}

// 使用defineAsyncComponent进行更精细的控制
import { defineAsyncComponent } from 'vue'

export default {
  components: {
    'async-component': defineAsyncComponent({
      loader: () => import('./AsyncComponent.vue'),
      loadingComponent: LoadingComponent, // 加载时显示的组件
      errorComponent: ErrorComponent, // 错误时显示的组件
      delay: 200, // 延迟显示加载组件的时间
      timeout: 3000 // 超时时间
    })
  }
}

// 结合Suspense使用（Vue 3）
<template>
  <Suspense>
    <template #default>
      <AsyncComponent />
    </template>
    <template #fallback>
      <div>Loading...</div>
    </template>
  </Suspense>
</template>
```

### v-once与v-memo指令

Vue 3提供了v-once和v-memo指令，可以优化特定场景的渲染性能。

```javascript
// v-once - 只渲染元素和组件一次
<template>
  <div>
    <!-- 只渲染一次，即使数据变化也不会更新 -->
    <span v-once>{{ staticMessage }}</span>
    
    <!-- 组件也只渲染一次 -->
    <ExpensiveComponent v-once :data="staticData" />
  </div>
</template>

// v-memo - 根据条件缓存子树
<template>
  <div>
    <!-- 只有当id变化时才重新渲染 -->
    <div v-memo="[user.id]">
      <UserProfile :user="user" />
      <UserPosts :posts="user.posts" />
    </div>
    
    <!-- 复杂条件 -->
    <div v-memo="[shouldUpdate, user.id]">
      <ComplexComponent :user="user" :settings="settings" />
    </div>
  </div>
</template>

// 在循环中使用v-memo优化
<template>
  <div>
    <div v-for="item in list" :key="item.id" v-memo="[item.id, item.updatedAt]">
      <ExpensiveListItem :item="item" />
    </div>
  </div>
</template>
```

### Keep-Alive缓存组件

使用Keep-Alive可以缓存非活动组件实例，避免重复渲染。

```javascript
// 基本使用
<template>
  <div>
    <keep-alive>
      <component :is="currentComponent"></component>
    </keep-alive>
  </div>
</template>

// 使用include和exclude
<template>
  <div>
    <keep-alive :include="['ComponentA', 'ComponentB']" :exclude="['ComponentC']">
      <component :is="currentComponent"></component>
    </keep-alive>
  </div>
</template>

// 使用max限制缓存数量
<template>
  <div>
    <keep-alive :max="10">
      <router-view></router-view>
    </keep-alive>
  </div>
</template>

// 在组件中使用activated和deactivated钩子
export default {
  activated() {
    // 组件被激活时调用
    this.fetchData()
  },
  
  deactivated() {
    // 组件被停用时调用
    this.cleanup()
  }
}
```

## 内存管理优化

### 避免内存泄漏

内存泄漏是长期运行应用中的常见问题，特别是在单页应用中。

```javascript
// 常见的内存泄漏场景及解决方案

// 1. 未清理的定时器
export default {
  data() {
    return {
      timer: null
    }
  },
  
  created() {
    // 创建定时器
    this.timer = setInterval(() => {
      console.log('Timer tick')
    }, 1000)
  },
  
  beforeUnmount() { // Vue 3使用beforeUnmount，Vue 2使用beforeDestroy
    // 组件销毁前清理定时器
    if (this.timer) {
      clearInterval(this.timer)
      this.timer = null
    }
  }
}

// 2. 未清理的事件监听器
export default {
  mounted() {
    // 添加全局事件监听
    window.addEventListener('resize', this.handleResize)
    
    // 添加DOM事件监听
    document.getElementById('my-element').addEventListener('click', this.handleClick)
  },
  
  beforeUnmount() {
    // 移除全局事件监听
    window.removeEventListener('resize', this.handleResize)
    
    // 移除DOM事件监听
    document.getElementById('my-element').removeEventListener('click', this.handleClick)
  },
  
  methods: {
    handleResize() {
      // 处理窗口大小变化
    },
    
    handleClick() {
      // 处理点击事件
    }
  }
}

// 3. 未清理的第三方库实例
export default {
  data() {
    return {
      chartInstance: null,
      mapInstance: null
    }
  },
  
  mounted() {
    // 初始化图表库
    this.chartInstance = new Chart(this.$refs.canvas, {
      // 图表配置
    })
    
    // 初始化地图库
    this.mapInstance = new Map(this.$refs.mapContainer, {
      // 地图配置
    })
  },
  
  beforeUnmount() {
    // 销毁图表实例
    if (this.chartInstance) {
      this.chartInstance.destroy()
      this.chartInstance = null
    }
    
    // 销毁地图实例
    if (this.mapInstance) {
      this.mapInstance.destroy()
      this.mapInstance = null
    }
  }
}

// 4. 使用组合式API的自动清理
import { onMounted, onUnmounted, ref } from 'vue'

export default {
  setup() {
    const timer = ref(null)
    
    onMounted(() => {
      timer.value = setInterval(() => {
        console.log('Timer tick')
      }, 1000)
    })
    
    onUnmounted(() => {
      if (timer.value) {
        clearInterval(timer.value)
        timer.value = null
      }
    })
    
    return {}
  }
}

// 使用watchEffect自动清理
import { watchEffect } from 'vue'

export default {
  setup() {
    watchEffect((onCleanup) => {
      const timer = setInterval(() => {
        console.log('Timer tick')
      }, 1000)
      
      // 注册清理函数
      onCleanup(() => {
        clearInterval(timer)
      })
    })
    
    return {}
  }
}
```

### 大数据列表优化

处理大量数据时，需要采用特殊策略避免性能问题。

```javascript
// 虚拟滚动 - 只渲染可见区域的项目
<template>
  <div class="virtual-list-container" @scroll="handleScroll" ref="container">
    <div class="virtual-list-phantom" :style="{ height: totalHeight + 'px' }"></div>
    <div class="virtual-list-content" :style="{ transform: `translateY(${offsetY}px)` }">
      <div v-for="item in visibleItems" :key="item.id" class="virtual-list-item">
        {{ item.content }}
      </div>
    </div>
  </div>
</template>

<script>
import { ref, computed, onMounted, onUnmounted } from 'vue'

export default {
  props: {
    items: Array,
    itemHeight: {
      type: Number,
      default: 50
    },
    visibleCount: {
      type: Number,
      default: 10
    }
  },
  
  setup(props) {
    const container = ref(null)
    const scrollTop = ref(0)
    
    const totalHeight = computed(() => props.items.length * props.itemHeight)
    
    const startIndex = computed(() => Math.floor(scrollTop.value / props.itemHeight))
    
    const endIndex = computed(() => Math.min(
      startIndex.value + props.visibleCount,
      props.items.length - 1
    ))
    
    const offsetY = computed(() => startIndex.value * props.itemHeight)
    
    const visibleItems = computed(() => 
      props.items.slice(startIndex.value, endIndex.value + 1)
    )
    
    function handleScroll() {
      scrollTop.value = container.value.scrollTop
    }
    
    return {
      container,
      totalHeight,
      offsetY,
      visibleItems,
      handleScroll
    }
  }
}
</script>

// 分页加载 - 按需加载数据
<template>
  <div>
    <div v-for="item in items" :key="item.id" class="item">
      {{ item.content }}
    </div>
    
    <div v-if="loading" class="loading">
      Loading...
    </div>
    
    <div v-if="hasMore && !loading" class="load-more" @click="loadMore">
      Load More
    </div>
  </div>
</template>

<script>
import { ref, computed } from 'vue'

export default {
  setup() {
    const items = ref([])
    const page = ref(1)
    const pageSize = ref(20)
    const loading = ref(false)
    const total = ref(0)
    
    const hasMore = computed(() => items.value.length < total.value)
    
    async function fetchData(pageNum = 1) {
      loading.value = true
      
      try {
        const response = await fetch(`https://api.example.com/items?page=${pageNum}&size=${pageSize.value}`)
        const data = await response.json()
        
        if (pageNum === 1) {
          items.value = data.items
        } else {
          items.value = [...items.value, ...data.items]
        }
        
        total.value = data.total
        page.value = pageNum
      } catch (error) {
        console.error('Failed to fetch data:', error)
      } finally {
        loading.value = false
      }
    }
    
    function loadMore() {
      if (hasMore.value && !loading.value) {
        fetchData(page.value + 1)
      }
    }
    
    // 初始加载
    fetchData()
    
    return {
      items,
      loading,
      hasMore,
      loadMore
    }
  }
}
</script>

// 使用Intersection Observer实现无限滚动
<template>
  <div>
    <div v-for="item in items" :key="item.id" class="item">
      {{ item.content }}
    </div>
    
    <div v-if="loading" class="loading">
      Loading...
    </div>
    
    <div ref="sentinel" class="sentinel"></div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue'

export default {
  setup() {
    const items = ref([])
    const loading = ref(false)
    const page = ref(1)
    const sentinel = ref(null)
    let observer = null
    
    async function loadMore() {
      if (loading.value) return
      
      loading.value = true
      
      try {
        const response = await fetch(`https://api.example.com/items?page=${page.value}`)
        const data = await response.json()
        
        items.value = [...items.value, ...data.items]
        page.value++
      } catch (error) {
        console.error('Failed to load more items:', error)
      } finally {
        loading.value = false
      }
    }
    
    onMounted(() => {
      observer = new IntersectionObserver((entries) => {
        if (entries[0].isIntersecting) {
          loadMore()
        }
      }, {
        root: null,
        rootMargin: '0px',
        threshold: 1.0
      })
      
      if (sentinel.value) {
        observer.observe(sentinel.value)
      }
      
      // 初始加载
      loadMore()
    })
    
    onUnmounted(() => {
      if (observer && sentinel.value) {
        observer.unobserve(sentinel.value)
      }
    })
    
    return {
      items,
      loading,
      sentinel
    }
  }
}
</script>
```

## 打包与构建优化

### 代码分割

合理的代码分割可以显著减少初始加载时间。

```javascript
// 路由级别的代码分割
import { createRouter, createWebHistory } from 'vue-router'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('../views/Home.vue')
  },
  {
    path: '/about',
    name: 'About',
    component: () => import('../views/About.vue')
  },
  {
    path: '/admin',
    name: 'Admin',
    component: () => import('../views/Admin.vue'),
    // 嵌套路由也可以懒加载
    children: [
      {
        path: 'users',
        component: () => import('../views/admin/Users.vue')
      },
      {
        path: 'settings',
        component: () => import('../views/admin/Settings.vue')
      }
    ]
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes
})

export default router

// 组件级别的代码分割
import { defineAsyncComponent } from 'vue'

export default {
  components: {
    'heavy-chart': defineAsyncComponent(() => import('./HeavyChart.vue')),
    'admin-panel': defineAsyncComponent(() => import('./AdminPanel.vue'))
  }
}

// 使用webpack的魔法注释进行更精细的控制
const routes = [
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import(
      /* webpackChunkName: "dashboard" */ 
      '../views/Dashboard.vue'
    )
  }
]

// 使用webpackPrefetch预加载
const routes = [
  {
    path: '/about',
    name: 'About',
    component: () => import(
      /* webpackChunkName: "about" */
      /* webpackPrefetch: true */
      '../views/About.vue'
    )
  }
]

// 使用webpackPreload预加载关键资源
const routes = [
  {
    path: '/critical',
    name: 'Critical',
    component: () => import(
      /* webpackChunkName: "critical" */
      /* webpackPreload: true */
      '../views/Critical.vue'
    )
  }
]
```

### Tree Shaking优化

Tree Shaking可以移除未使用的代码，减少包大小。

```javascript
// 使用具名导入而不是默认导入
// 不好的做法
import _ from 'lodash'

// 好的做法
import { debounce, throttle } from 'lodash-es'

// 或者使用babel-plugin-lodash
import _ from 'lodash'
_.debounce(function() {
  console.log('Debounced')
}, 300)

// 在组件中只导入需要的功能
// 不好的做法
import * as Vue from 'vue'

// 好的做法
import { ref, computed, onMounted } from 'vue'

// 配置webpack进行tree shaking
// webpack.config.js
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: false
  }
}

// 在package.json中标记无副作用的模块
{
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/style/index.js"
  ]
}
```

### 资源优化

优化静态资源可以显著提高加载性能。

```javascript
// 图片优化
<template>
  <!-- 使用现代图片格式 -->
  <picture>
    <source srcset="image.webp" type="image/webp">
    <source srcset="image.avif" type="image/avif">
    <img src="image.jpg" alt="Description" loading="lazy">
  </picture>
  
  <!-- 使用响应式图片 -->
  <img 
    srcset="image-small.jpg 480w, image-medium.jpg 768w, image-large.jpg 1200w"
    sizes="(max-width: 480px) 480px, (max-width: 768px) 768px, 1200px"
    src="image-medium.jpg"
    alt="Description"
    loading="lazy"
  >
</template>

// 动态导入图片
export default {
  data() {
    return {
      imageUrl: null
    }
  },
  
  async created() {
    // 动态导入图片
    const imageModule = await import('@/assets/images/dynamic-image.jpg')
    this.imageUrl = imageModule.default
  }
}

// 使用CDN加载第三方库
// public/index.html
<script src="https://cdn.jsdelivr.net/npm/vue@3.2.31/dist/vue.global.prod.js"></script>

// webpack配置外部依赖
// webpack.config.js
module.exports = {
  externals: {
    vue: 'Vue',
    'vue-router': 'VueRouter',
    axios: 'axios'
  }
}
```

## 调试技巧与工具

### Vue DevTools

Vue DevTools是调试Vue应用的必备工具。

```javascript
// 在组件中添加调试信息
export default {
  data() {
    return {
      user: { name: 'John', age: 30 }
    }
  },
  
  // 添加devtools选项
  devtools: {
    // 自定义组件在DevTools中的显示名称
    name: 'UserProfile',
    
    // 自定义组件在DevTools中的显示颜色
    color: '#ff6347'
  },
  
  // 在开发环境中暴露调试方法
  methods: {
    debugUser() {
      if (process.env.NODE_ENV === 'development') {
        console.log('User data:', this.user)
        // 在DevTools中选中当前组件
        this.$parent.$emit('devtools:select', this)
      }
    }
  }
}

// 使用组合式API
import { ref, onMounted } from 'vue'

export default {
  setup() {
    const user = ref({ name: 'John', age: 30 })
    
    // 在开发环境中暴露调试方法
    function debugUser() {
      if (process.env.NODE_ENV === 'development') {
        console.log('User data:', user.value)
        // 在DevTools中可以通过getCurrentInstance访问组件实例
      }
    }
    
    return {
      user,
      debugUser
    }
  }
}
```

### 性能分析

使用浏览器性能分析工具识别性能瓶颈。

```javascript
// 使用performance API进行性能测量
export default {
  methods: {
    async performExpensiveOperation() {
      // 开始测量
      performance.mark('operation-start')
      
      // 执行耗时操作
      const result = await this.expensiveCalculation()
      
      // 结束测量
      performance.mark('operation-end')
      
      // 测量两个标记之间的时间
      performance.measure('operation-duration', 'operation-start', 'operation-end')
      
      // 获取测量结果
      const measures = performance.getEntriesByName('operation-duration')
      console.log('Operation duration:', measures[0].duration)
      
      return result
    },
    
    async expensiveCalculation() {
      // 模拟耗时操作
      return new Promise(resolve => {
        setTimeout(() => {
          resolve('Calculation result')
        }, 1000)
      })
    }
  }
}

// 使用Vue的性能API
import { onMounted } from 'vue'

export default {
  setup() {
    onMounted(() => {
      // 标记组件渲染完成
      if (process.env.NODE_ENV === 'development') {
        console.log('Component mounted at:', performance.now())
      }
    })
  }
}

// 使用React DevTools Profiler类似的功能
// 在Vue 3中，可以使用Performance API进行组件性能分析
import { onMounted, onUnmounted, ref } from 'vue'

export default {
  setup() {
    const renderStartTime = ref(0)
    
    onMounted(() => {
      renderStartTime.value = performance.now()
      console.log(`Component ${componentName} render time: ${renderStartTime.value}ms`)
    })
    
    return {
      renderStartTime
    }
  }
}
```

### 错误处理与日志

合理的错误处理和日志记录有助于快速定位问题。

```javascript
// 全局错误处理
// main.js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

// 全局错误处理器
app.config.errorHandler = (err, vm, info) => {
  console.error('Global error:', err)
  console.error('Component:', vm)
  console.error('Error info:', info)
  
  // 发送错误到监控服务
  if (process.env.NODE_ENV === 'production') {
    sendErrorToMonitoringService(err, vm, info)
  }
}

// 全局警告处理器
app.config.warnHandler = (msg, vm, trace) => {
  console.warn('Global warning:', msg)
  console.warn('Component:', vm)
  console.warn('Trace:', trace)
}

app.mount('#app')

// 组件级错误处理
export default {
  errorCaptured(err, vm, info) {
    console.error('Component error:', err)
    console.error('Component:', vm)
    console.error('Error info:', info)
    
    // 返回false可以阻止错误继续向上传播
    // return false
    
    // 可以返回一个Promise来处理异步错误
    return handleComponentError(err, vm, info)
  }
}

// 使用组合式API的错误处理
import { onErrorCaptured } from 'vue'

export default {
  setup() {
    onErrorCaptured((err, vm, info) => {
      console.error('Component error:', err)
      console.error('Component:', vm)
      console.error('Error info:', info)
      
      // 返回false阻止错误继续传播
      return false
    })
    
    return {}
  }
}

// 自定义日志服务
class Logger {
  constructor(level = 'info') {
    this.level = level
    this.levels = {
      debug: 0,
      info: 1,
      warn: 2,
      error: 3
    }
  }
  
  debug(message, ...args) {
    if (this.levels.debug >= this.levels[this.level]) {
      console.debug(`[DEBUG] ${message}`, ...args)
      this.logToServer('debug', message, args)
    }
  }
  
  info(message, ...args) {
    if (this.levels.info >= this.levels[this.level]) {
      console.info(`[INFO] ${message}`, ...args)
      this.logToServer('info', message, args)
    }
  }
  
  warn(message, ...args) {
    if (this.levels.warn >= this.levels[this.level]) {
      console.warn(`[WARN] ${message}`, ...args)
      this.logToServer('warn', message, args)
    }
  }
  
  error(message, ...args) {
    if (this.levels.error >= this.levels[this.level]) {
      console.error(`[ERROR] ${message}`, ...args)
      this.logToServer('error', message, args)
    }
  }
  
  logToServer(level, message, args) {
    if (process.env.NODE_ENV === 'production') {
      // 发送日志到服务器
      fetch('/api/logs', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          level,
          message,
          args,
          timestamp: new Date().toISOString(),
          url: window.location.href,
          userAgent: navigator.userAgent
        })
      }).catch(err => {
        console.error('Failed to send log to server:', err)
      })
    }
  }
}

// 创建全局日志实例
const logger = new Logger(process.env.NODE_ENV === 'development' ? 'debug' : 'info')

// 在组件中使用
export default {
  methods: {
    fetchData() {
      logger.debug('Fetching data...')
      
      fetch('https://api.example.com/data')
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`)
          }
          return response.json()
        })
        .then(data => {
          logger.info('Data fetched successfully:', data)
        })
        .catch(error => {
          logger.error('Failed to fetch data:', error)
        })
    }
  }
}
```

## 总结

Vue.js性能优化是一个系统工程，需要从多个层面进行考虑：

1. **渲染性能优化**：合理使用key属性、计算属性缓存、侦听器优化等
2. **组件性能优化**：使用函数式组件、组件懒加载、v-once/v-memo指令、Keep-Alive缓存等
3. **内存管理优化**：避免内存泄漏、优化大数据列表处理等
4. **打包与构建优化**：代码分割、Tree Shaking、资源优化等
5. **调试技巧与工具**：Vue DevTools、性能分析、错误处理与日志等

通过综合运用这些优化策略和技巧，我们可以构建出高性能、可维护的Vue应用，提供流畅的用户体验。在实际开发中，应该根据应用的具体场景和性能瓶颈，选择合适的优化方案，并通过性能监控工具持续优化应用性能。