---
title: "React性能优化与最佳实践（二）：列表渲染优化与代码分割"
excerpt: "深入探讨React中列表渲染的优化技巧，包括虚拟化长列表、key优化，以及代码分割与懒加载的实现方法，帮助开发者构建高性能的React应用。"
coverImage: "/images/react-performance-2.jpg"
date: "2025-10-24"
author:
  name: "前端架构师"
  picture: "/images/authors/frontend.jpg"
ogImage:
  url: "/images/react-performance-2-og.jpg"
  width: 1200
  height: 630
series: "React性能优化与最佳实践"
weight: 2
---

# React性能优化与最佳实践（二）：列表渲染优化与代码分割

在上一篇文章中，我们探讨了React渲染机制与组件渲染优化。本篇将深入列表渲染优化和代码分割技术，这些是构建高性能React应用的关键技巧。

## 列表渲染优化

### 虚拟化长列表

对于大型列表，使用虚拟滚动只渲染可见区域：

```jsx
import React, { useState, useRef, useEffect, useMemo } from 'react'

// 简单的虚拟滚动实现
function VirtualList({ items, itemHeight, containerHeight }) {
  const [scrollTop, setScrollTop] = useState(0)
  const containerRef = useRef(null)
  
  // 计算可见区域的项目
  const visibleItems = useMemo(() => {
    const startIndex = Math.floor(scrollTop / itemHeight)
    const endIndex = Math.min(
      startIndex + Math.ceil(containerHeight / itemHeight) + 1,
      items.length - 1
    )
    
    return items.slice(startIndex, endIndex + 1).map((item, index) => ({
      ...item,
      index: startIndex + index
    }))
  }, [items, itemHeight, containerHeight, scrollTop])
  
  const handleScroll = () => {
    setScrollTop(containerRef.current.scrollTop)
  }
  
  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: 'auto'
      }}
      onScroll={handleScroll}
    >
      <div style={{ height: items.length * itemHeight, position: 'relative' }}>
        {visibleItems.map(item => (
          <div
            key={item.id}
            style={{
              position: 'absolute',
              top: item.index * itemHeight,
              height: itemHeight,
              width: '100%'
            }}
          >
            {item.content}
          </div>
        ))}
      </div>
    </div>
  )
}

// 使用示例
function LargeListDemo() {
  const [items] = useState(() => 
    Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      content: `Item ${i}`,
      value: Math.random() * 100
    }))
  )
  
  return (
    <div>
      <h2>Virtual List Demo</h2>
      <VirtualList
        items={items}
        itemHeight={50}
        containerHeight={500}
      />
    </div>
  )
}

// 使用react-window库
import { FixedSizeList as List } from 'react-window'

function ReactWindowExample() {
  const [items] = useState(() => 
    Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      text: `Item ${i}`,
      value: Math.floor(Math.random() * 100)
    }))
  )
  
  // 渲染单个行
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].text} - Value: {items[index].value}
    </div>
  )
  
  return (
    <List
      height={500}
      itemCount={items.length}
      itemSize={35}
      width="100%"
    >
      {Row}
    </List>
  )
}

// 使用react-virtualized库
import { Table, Column } from 'react-virtualized'
import 'react-virtualized/styles.css'

function ReactVirtualizedTable() {
  const [list] = useState(() => 
    Array.from({ length: 10000 }, (_, i) => ({
      id: i,
      name: `Name ${i}`,
      email: `email${i}@example.com`,
      age: Math.floor(Math.random() * 50) + 18
    }))
  )
  
  return (
    <Table
      width={800}
      height={500}
      headerHeight={50}
      rowHeight={40}
      rowCount={list.length}
      rowGetter={({ index }) => list[index]}
    >
      <Column label="ID" dataKey="id" width={100} />
      <Column label="Name" dataKey="name" width={200} />
      <Column label="Email" dataKey="email" width={250} />
      <Column label="Age" dataKey="age" width={100} />
    </Table>
  )
}
```

### 列表key优化

正确使用key属性优化列表渲染：

```jsx
// 不好的做法 - 使用数组索引作为key
function BadKeyExample({ items }) {
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>
          {item.name}
          <button onClick={() => removeItem(index)}>Remove</button>
        </li>
      ))}
    </ul>
  )
}

// 好的做法 - 使用唯一ID作为key
function GoodKeyExample({ items }) {
  return (
    <ul>
      {items.map(item => (
        <li key={item.id}>
          {item.name}
          <button onClick={() => removeItem(item.id)}>Remove</button>
        </li>
      ))}
    </ul>
  )
}

// 复杂列表优化
function OptimizedList({ items }) {
  const [selectedId, setSelectedId] = useState(null)
  
  // 使用useMemo缓存渲染的列表项
  const listItems = useMemo(() => 
    items.map(item => (
      <ListItem
        key={item.id}
        item={item}
        isSelected={selectedId === item.id}
        onSelect={() => setSelectedId(item.id)}
      />
    )), [items, selectedId])
  
  return <ul>{listItems}</ul>
}

// 优化的列表项组件
const ListItem = React.memo(function ListItem({ item, isSelected, onSelect }) {
  return (
    <li 
      className={isSelected ? 'selected' : ''}
      onClick={onSelect}
    >
      {item.name}
    </li>
  )
})
```

## 代码分割与懒加载

### 动态导入

使用动态导入实现代码分割：

```jsx
import React, { Suspense, lazy } from 'react'

// 懒加载组件
const LazyComponent = lazy(() => import('./LazyComponent'))

function App() {
  return (
    <div>
      <h1>My App</h1>
      
      {/* 使用Suspense包装懒加载组件 */}
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  )
}

// 路由级别的代码分割
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom'

const Home = lazy(() => import('./pages/Home'))
const About = lazy(() => import('./pages/About'))
const Products = lazy(() => import('./pages/Products'))
const ProductDetail = lazy(() => import('./pages/ProductDetail'))

function AppRouter() {
  return (
    <BrowserRouter>
      <nav>
        <Link to="/">Home</Link>
        <Link to="/about">About</Link>
        <Link to="/products">Products</Link>
      </nav>
      
      <Suspense fallback={<div>Loading page...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
          <Route path="/products" element={<Products />} />
          <Route path="/products/:id" element={<ProductDetail />} />
        </Routes>
      </Suspense>
    </BrowserRouter>
  )
}

// 条件加载组件
function ConditionalLoading() {
  const [showDetails, setShowDetails] = useState(false)
  
  // 只有当showDetails为true时才加载Details组件
  const LazyDetails = lazy(() => import('./Details'))
  
  return (
    <div>
      <button onClick={() => setShowDetails(true)}>
        Show Details
      </button>
      
      {showDetails && (
        <Suspense fallback={<div>Loading details...</div>}>
          <LazyDetails />
        </Suspense>
      )}
    </div>
  )
}

// 预加载组件
function PreloadExample() {
  const [componentLoaded, setComponentLoaded] = useState(false)
  const ComponentRef = useRef(null)
  
  // 预加载组件但不立即渲染
  const preloadComponent = () => {
    import('./HeavyComponent').then(module => {
      ComponentRef.current = module.default
      setComponentLoaded(true)
    })
  }
  
  const renderComponent = () => {
    if (ComponentRef.current) {
      const Component = ComponentRef.current
      return <Component />
    }
    return null
  }
  
  return (
    <div>
      <button onClick={preloadComponent}>Preload Component</button>
      <button onClick={() => setComponentLoaded(true)}>
        Render Component
      </button>
      
      {componentLoaded && (
        <Suspense fallback={<div>Loading...</div>}>
          {renderComponent()}
        </Suspense>
      )}
    </div>
  )
}
```

### Webpack代码分割

配置Webpack进行代码分割：

```javascript
// webpack.config.js
module.exports = {
  // ...其他配置
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // 将node_modules中的代码打包到vendor
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        // 公共代码打包到common
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true
        }
      }
    }
  }
}

// 使用动态导入指定chunk名称
const LazyComponent = lazy(() => 
  import(/* webpackChunkName: "lazy-component" */ './LazyComponent')
)

// 多个组件打包到同一个chunk
const AdminDashboard = lazy(() => 
  import(/* webpackChunkName: "admin" */ './pages/AdminDashboard')
)
const UserManagement = lazy(() => 
  import(/* webpackChunkName: "admin" */ './pages/UserManagement')
)
const Reports = lazy(() => 
  import(/* webpackChunkName: "admin" */ './pages/Reports')
)
```

## 总结

列表渲染优化和代码分割是构建高性能React应用的关键技术。通过虚拟化长列表、正确使用key属性，以及合理实现代码分割与懒加载，我们可以显著提升应用的性能和用户体验。

在下一篇文章中，我们将探讨内存管理、资源优化以及构建与部署优化，进一步完善React应用的性能优化策略。